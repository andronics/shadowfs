> """
> ShadowFS Foundation: Safe File Operations
  
> This module provides secure file I/O operations with proper error handling,
> resource management, and safety checks.
  
> Following Meta-Architecture v1.0.0 principles.
> """
! import os
! import stat
! import tempfile
! import shutil
! from pathlib import Path
! from typing import Optional, Union, List, BinaryIO, TextIO, Iterator
! from contextlib import contextmanager
! import hashlib
  
! from shadowfs.foundation.constants import (
!     ErrorCode,
!     FileContent,
!     FileAttributes,
!     Limits,
! )
! from shadowfs.foundation.path_utils import (
!     PathError,
!     normalize_path,
!     is_safe_path,
!     validate_filename,
! )
  
  
! class FileOperationError(Exception):
!     """Base exception for file operation errors."""
  
!     def __init__(self, message: str, error_code: ErrorCode = ErrorCode.INTERNAL_ERROR):
!         """Initialize FileOperationError.
  
!         Args:
!             message: Error message
!             error_code: Associated error code
!         """
!         super().__init__(message)
!         self.error_code = error_code
  
  
! def read_file(
!     path: str,
!     binary: bool = True,
!     size_limit: Optional[int] = None
! ) -> Union[bytes, str]:
!     """Safely read file contents.
  
!     Args:
!         path: Path to file
!         binary: Whether to read in binary mode
!         size_limit: Maximum bytes to read (default: Limits.MAX_FILE_SIZE)
  
!     Returns:
!         File contents as bytes or string
  
!     Raises:
!         FileOperationError: If read fails or exceeds size limit
!     """
!     if size_limit is None:
!         size_limit = Limits.MAX_FILE_SIZE
  
!     try:
!         path = normalize_path(path)
  
          # Check file size before reading
!         file_size = os.path.getsize(path)
!         if file_size > size_limit:
!             raise FileOperationError(
!                 f"File size ({file_size}) exceeds limit ({size_limit})",
!                 ErrorCode.INVALID_INPUT
!             )
  
!         mode = "rb" if binary else "r"
!         with open(path, mode) as f:
!             content = f.read(size_limit)
  
!         return content
  
!     except FileNotFoundError:
!         raise FileOperationError(
!             f"File not found: {path}",
!             ErrorCode.NOT_FOUND
!         )
!     except PermissionError:
!         raise FileOperationError(
!             f"Permission denied: {path}",
!             ErrorCode.PERMISSION_DENIED
!         )
!     except (OSError, IOError) as e:
!         raise FileOperationError(
!             f"Failed to read file: {e}",
!             ErrorCode.INTERNAL_ERROR
!         )
  
  
! def write_file(
!     path: str,
!     content: Union[bytes, str],
!     binary: bool = True,
!     atomic: bool = True,
!     create_dirs: bool = False
! ) -> None:
!     """Safely write content to file.
  
!     Args:
!         path: Path to file
!         content: Content to write
!         binary: Whether to write in binary mode
!         atomic: Use atomic write (temp file + rename)
!         create_dirs: Create parent directories if they don't exist
  
!     Raises:
!         FileOperationError: If write fails
!     """
!     try:
!         path = normalize_path(path)
  
          # Create parent directories if requested
!         if create_dirs:
!             parent_dir = os.path.dirname(path)
!             if parent_dir and not os.path.exists(parent_dir):
!                 os.makedirs(parent_dir, mode=0o755)
  
!         mode = "wb" if binary else "w"
  
!         if atomic:
              # Atomic write using temporary file
!             dir_name = os.path.dirname(path)
!             with tempfile.NamedTemporaryFile(
!                 mode=mode,
!                 dir=dir_name,
!                 delete=False
!             ) as tmp_file:
!                 tmp_file.write(content)
!                 tmp_path = tmp_file.name
  
              # Atomic rename
!             os.replace(tmp_path, path)
!         else:
              # Direct write
!             with open(path, mode) as f:
!                 f.write(content)
  
!     except PermissionError:
!         raise FileOperationError(
!             f"Permission denied: {path}",
!             ErrorCode.PERMISSION_DENIED
!         )
!     except (OSError, IOError) as e:
!         raise FileOperationError(
!             f"Failed to write file: {e}",
!             ErrorCode.INTERNAL_ERROR
!         )
  
  
! def delete_file(path: str, safe: bool = True) -> None:
!     """Safely delete a file.
  
!     Args:
!         path: Path to file
!         safe: If True, only delete regular files (not dirs, symlinks, etc)
  
!     Raises:
!         FileOperationError: If deletion fails
!     """
!     try:
          # For delete, we need to check symlinks BEFORE normalization
          # because normalize_path resolves symlinks
!         original_path = path
  
!         if safe:
              # Don't follow symlinks - check this first!
!             if os.path.islink(path):
!                 raise FileOperationError(
!                     f"Cannot delete symlink: {path}",
!                     ErrorCode.INVALID_INPUT
!                 )
  
              # For safe mode, normalize the path (resolves symlinks) only if it exists
!             if os.path.exists(path):
!                 path = normalize_path(path)
  
                  # Check it's a regular file
!                 if not os.path.isfile(path):
!                     raise FileOperationError(
!                         f"Not a regular file: {path}",
!                         ErrorCode.INVALID_INPUT
!                     )
!         else:
              # For unsafe mode, don't resolve symlinks - just validate the path
              # We still want to validate the path but not resolve symlinks
!             if not path:
!                 raise FileOperationError("Path cannot be empty", ErrorCode.INVALID_INPUT)
              # Use os.path.abspath instead of normalize_path to avoid resolving symlinks
!             path = os.path.abspath(path)
  
!         os.unlink(path)
  
!     except FileNotFoundError:
!         raise FileOperationError(
!             f"File not found: {path}",
!             ErrorCode.NOT_FOUND
!         )
!     except PermissionError:
!         raise FileOperationError(
!             f"Permission denied: {path}",
!             ErrorCode.PERMISSION_DENIED
!         )
!     except (OSError, IOError) as e:
!         raise FileOperationError(
!             f"Failed to delete file: {e}",
!             ErrorCode.INTERNAL_ERROR
!         )
  
  
! def copy_file(
!     source: str,
!     destination: str,
!     preserve_metadata: bool = True,
!     overwrite: bool = False
! ) -> None:
!     """Safely copy a file.
  
!     Args:
!         source: Source file path
!         destination: Destination file path
!         preserve_metadata: Preserve file metadata (permissions, timestamps)
!         overwrite: Allow overwriting existing files
  
!     Raises:
!         FileOperationError: If copy fails
!     """
!     try:
!         source = normalize_path(source)
!         destination = normalize_path(destination)
  
          # Check source exists
!         if not os.path.exists(source):
!             raise FileOperationError(
!                 f"Source file not found: {source}",
!                 ErrorCode.NOT_FOUND
!             )
  
          # Check destination
!         if os.path.exists(destination) and not overwrite:
!             raise FileOperationError(
!                 f"Destination already exists: {destination}",
!                 ErrorCode.CONFLICT
!             )
  
!         if preserve_metadata:
!             shutil.copy2(source, destination)
!         else:
!             shutil.copy(source, destination)
  
!     except PermissionError:
!         raise FileOperationError(
!             f"Permission denied",
!             ErrorCode.PERMISSION_DENIED
!         )
!     except (OSError, IOError, shutil.Error) as e:
!         raise FileOperationError(
!             f"Failed to copy file: {e}",
!             ErrorCode.INTERNAL_ERROR
!         )
  
  
! def move_file(
!     source: str,
!     destination: str,
!     overwrite: bool = False
! ) -> None:
!     """Safely move a file.
  
!     Args:
!         source: Source file path
!         destination: Destination file path
!         overwrite: Allow overwriting existing files
  
!     Raises:
!         FileOperationError: If move fails
!     """
!     try:
!         source = normalize_path(source)
!         destination = normalize_path(destination)
  
          # Check source exists
!         if not os.path.exists(source):
!             raise FileOperationError(
!                 f"Source file not found: {source}",
!                 ErrorCode.NOT_FOUND
!             )
  
          # Check destination
!         if os.path.exists(destination) and not overwrite:
!             raise FileOperationError(
!                 f"Destination already exists: {destination}",
!                 ErrorCode.CONFLICT
!             )
  
!         shutil.move(source, destination)
  
!     except PermissionError:
!         raise FileOperationError(
!             f"Permission denied",
!             ErrorCode.PERMISSION_DENIED
!         )
!     except (OSError, IOError, shutil.Error) as e:
!         raise FileOperationError(
!             f"Failed to move file: {e}",
!             ErrorCode.INTERNAL_ERROR
!         )
  
  
! def get_file_attributes(path: str, follow_symlinks: bool = True) -> FileAttributes:
!     """Get file attributes (stat information).
  
!     Args:
!         path: Path to file
!         follow_symlinks: Whether to follow symbolic links
  
!     Returns:
!         FileAttributes object
  
!     Raises:
!         FileOperationError: If stat fails
!     """
!     try:
          # Only normalize path if we're following symlinks
          # Otherwise normalize_path would resolve the symlink before we can check it
!         if follow_symlinks:
!             path = normalize_path(path)
!         else:
              # For lstat, we want to check the symlink itself, not its target
              # Just ensure it's an absolute path without resolving symlinks
!             if not path:
!                 raise FileOperationError("Path cannot be empty", ErrorCode.INVALID_INPUT)
!             path = os.path.abspath(path)
  
!         if follow_symlinks:
!             stat_result = os.stat(path)
!         else:
!             stat_result = os.lstat(path)
  
!         return FileAttributes(
!             st_mode=stat_result.st_mode,
!             st_ino=stat_result.st_ino,
!             st_dev=stat_result.st_dev,
!             st_nlink=stat_result.st_nlink,
!             st_uid=stat_result.st_uid,
!             st_gid=stat_result.st_gid,
!             st_size=stat_result.st_size,
!             st_atime=stat_result.st_atime,
!             st_mtime=stat_result.st_mtime,
!             st_ctime=stat_result.st_ctime
!         )
  
!     except FileNotFoundError:
!         raise FileOperationError(
!             f"File not found: {path}",
!             ErrorCode.NOT_FOUND
!         )
!     except PermissionError:
!         raise FileOperationError(
!             f"Permission denied: {path}",
!             ErrorCode.PERMISSION_DENIED
!         )
!     except (OSError, IOError) as e:
!         raise FileOperationError(
!             f"Failed to get file attributes: {e}",
!             ErrorCode.INTERNAL_ERROR
!         )
  
  
! def file_exists(path: str) -> bool:
!     """Check if file exists.
  
!     Args:
!         path: Path to check
  
!     Returns:
!         True if file exists, False otherwise
!     """
!     try:
!         path = normalize_path(path)
!         return os.path.exists(path)
!     except (PathError, OSError):
!         return False
  
  
! def is_readable(path: str) -> bool:
!     """Check if file is readable.
  
!     Args:
!         path: Path to check
  
!     Returns:
!         True if readable, False otherwise
!     """
!     try:
!         path = normalize_path(path)
!         return os.access(path, os.R_OK)
!     except (PathError, OSError):
!         return False
  
  
! def is_writable(path: str) -> bool:
!     """Check if file is writable.
  
!     Args:
!         path: Path to check
  
!     Returns:
!         True if writable, False otherwise
!     """
!     try:
!         path = normalize_path(path)
!         return os.access(path, os.W_OK)
!     except (PathError, OSError):
!         return False
  
  
! def is_executable(path: str) -> bool:
!     """Check if file is executable.
  
!     Args:
!         path: Path to check
  
!     Returns:
!         True if executable, False otherwise
!     """
!     try:
!         path = normalize_path(path)
!         return os.access(path, os.X_OK)
!     except (PathError, OSError):
!         return False
  
  
! def create_directory(
!     path: str,
!     mode: int = 0o755,
!     parents: bool = True,
!     exist_ok: bool = True
! ) -> None:
!     """Safely create a directory.
  
!     Args:
!         path: Directory path
!         mode: Directory permissions
!         parents: Create parent directories as needed
!         exist_ok: Don't error if directory already exists
  
!     Raises:
!         FileOperationError: If creation fails
!     """
!     try:
!         path = normalize_path(path)
  
!         if parents:
!             os.makedirs(path, mode=mode, exist_ok=exist_ok)
!         else:
!             if exist_ok and os.path.exists(path):
!                 return
!             os.mkdir(path, mode=mode)
  
!     except FileExistsError:
!         if not exist_ok:
!             raise FileOperationError(
!                 f"Directory already exists: {path}",
!                 ErrorCode.CONFLICT
!             )
!     except PermissionError:
!         raise FileOperationError(
!             f"Permission denied: {path}",
!             ErrorCode.PERMISSION_DENIED
!         )
!     except (OSError, IOError) as e:
!         raise FileOperationError(
!             f"Failed to create directory: {e}",
!             ErrorCode.INTERNAL_ERROR
!         )
  
  
! def list_directory(
!     path: str,
!     include_hidden: bool = False
! ) -> List[str]:
!     """List directory contents.
  
!     Args:
!         path: Directory path
!         include_hidden: Include hidden files (starting with .)
  
!     Returns:
!         List of filenames in directory
  
!     Raises:
!         FileOperationError: If listing fails
!     """
!     try:
!         path = normalize_path(path)
  
!         entries = os.listdir(path)
  
!         if not include_hidden:
!             entries = [e for e in entries if not e.startswith('.')]
  
!         return sorted(entries)
  
!     except FileNotFoundError:
!         raise FileOperationError(
!             f"Directory not found: {path}",
!             ErrorCode.NOT_FOUND
!         )
!     except NotADirectoryError:
!         raise FileOperationError(
!             f"Not a directory: {path}",
!             ErrorCode.INVALID_INPUT
!         )
!     except PermissionError:
!         raise FileOperationError(
!             f"Permission denied: {path}",
!             ErrorCode.PERMISSION_DENIED
!         )
!     except (OSError, IOError) as e:
!         raise FileOperationError(
!             f"Failed to list directory: {e}",
!             ErrorCode.INTERNAL_ERROR
!         )
  
  
! @contextmanager
! def open_file(
!     path: str,
!     mode: str = "r",
!     encoding: Optional[str] = "utf-8"
! ) -> Iterator[Union[BinaryIO, TextIO]]:
!     """Context manager for safe file operations.
  
!     Args:
!         path: File path
!         mode: Open mode ('r', 'w', 'rb', 'wb', etc)
!         encoding: Text encoding (None for binary modes)
  
!     Yields:
!         File handle
  
!     Raises:
!         FileOperationError: If open fails
!     """
!     file_handle = None
!     try:
!         path = normalize_path(path)
  
          # Determine if binary mode
!         binary_mode = 'b' in mode
  
!         if binary_mode:
!             file_handle = open(path, mode)
!         else:
!             file_handle = open(path, mode, encoding=encoding)
  
!         yield file_handle
  
!     except FileNotFoundError:
!         raise FileOperationError(
!             f"File not found: {path}",
!             ErrorCode.NOT_FOUND
!         )
!     except PermissionError:
!         raise FileOperationError(
!             f"Permission denied: {path}",
!             ErrorCode.PERMISSION_DENIED
!         )
!     except (OSError, IOError) as e:
!         raise FileOperationError(
!             f"Failed to open file: {e}",
!             ErrorCode.INTERNAL_ERROR
!         )
!     finally:
!         if file_handle:
!             try:
!                 file_handle.close()
!             except (OSError, IOError):
!                 pass  # Best effort close
  
  
! def calculate_checksum(
!     path: str,
!     algorithm: str = "sha256",
!     chunk_size: int = 8192
! ) -> str:
!     """Calculate file checksum.
  
!     Args:
!         path: File path
!         algorithm: Hash algorithm ('md5', 'sha1', 'sha256', etc)
!         chunk_size: Bytes to read at a time
  
!     Returns:
!         Hex digest of checksum
  
!     Raises:
!         FileOperationError: If checksum calculation fails
!     """
!     try:
!         path = normalize_path(path)
  
          # Get hash algorithm
!         try:
!             hasher = hashlib.new(algorithm)
!         except ValueError:
!             raise FileOperationError(
!                 f"Unsupported hash algorithm: {algorithm}",
!                 ErrorCode.INVALID_INPUT
!             )
  
          # Calculate checksum
!         with open(path, "rb") as f:
!             while chunk := f.read(chunk_size):
!                 hasher.update(chunk)
  
!         return hasher.hexdigest()
  
!     except FileNotFoundError:
!         raise FileOperationError(
!             f"File not found: {path}",
!             ErrorCode.NOT_FOUND
!         )
!     except PermissionError:
!         raise FileOperationError(
!             f"Permission denied: {path}",
!             ErrorCode.PERMISSION_DENIED
!         )
!     except (OSError, IOError) as e:
!         raise FileOperationError(
!             f"Failed to calculate checksum: {e}",
!             ErrorCode.INTERNAL_ERROR
!         )
  
  
! def set_permissions(path: str, mode: int) -> None:
!     """Set file permissions.
  
!     Args:
!         path: File path
!         mode: Permission mode (e.g., 0o644)
  
!     Raises:
!         FileOperationError: If permission change fails
!     """
!     try:
!         path = normalize_path(path)
!         os.chmod(path, mode)
  
!     except FileNotFoundError:
!         raise FileOperationError(
!             f"File not found: {path}",
!             ErrorCode.NOT_FOUND
!         )
!     except PermissionError:
!         raise FileOperationError(
!             f"Permission denied: {path}",
!             ErrorCode.PERMISSION_DENIED
!         )
!     except (OSError, IOError) as e:
!         raise FileOperationError(
!             f"Failed to set permissions: {e}",
!             ErrorCode.INTERNAL_ERROR
!         )
  
  
! def create_symlink(target: str, link_path: str) -> None:
!     """Create a symbolic link.
  
!     Args:
!         target: Target path (what the link points to)
!         link_path: Path where the symlink will be created
  
!     Raises:
!         FileOperationError: If symlink creation fails
!     """
!     try:
!         target = normalize_path(target)
!         link_path = normalize_path(link_path)
  
!         os.symlink(target, link_path)
  
!     except FileExistsError:
!         raise FileOperationError(
!             f"Link already exists: {link_path}",
!             ErrorCode.CONFLICT
!         )
!     except PermissionError:
!         raise FileOperationError(
!             f"Permission denied",
!             ErrorCode.PERMISSION_DENIED
!         )
!     except (OSError, IOError) as e:
!         raise FileOperationError(
!             f"Failed to create symlink: {e}",
!             ErrorCode.INTERNAL_ERROR
!         )
