#!/usr/bin/env python3
"""
Mount helper for ShadowFS - enables fstab integration.

This script is called by mount(8) when mounting a shadowfs filesystem.
It translates mount command arguments to shadowfs CLI format.

Installation:
    Install to /sbin/mount.shadowfs or /usr/sbin/mount.shadowfs

Usage by mount command:
    mount -t shadowfs /source /mountpoint -o options

Usage in /etc/fstab:
    /data  /mnt/shadowfs  shadowfs  ro,allow_other,config=/etc/shadowfs/config.yaml  0  0

The mount helper receives arguments in this format:
    mount.shadowfs <source> <mountpoint> [-o <options>] [-n] [-v] [-s]

Options:
    -o options   Comma-separated mount options
    -n           Do not write to /etc/mtab (ignored, for compatibility)
    -v           Verbose mode
    -s           Tolerate sloppy mount options (ignored, for compatibility)
    -h           Show help
"""

import argparse
import os
import subprocess
import sys
from pathlib import Path


def parse_mount_args():
    """Parse mount helper arguments."""
    # Check for help flag before parsing
    if '-h' in sys.argv or '--help' in sys.argv:
        print(__doc__)
        sys.exit(0)

    parser = argparse.ArgumentParser(
        description="ShadowFS mount helper",
        add_help=True
    )

    parser.add_argument('source', help='Source directory')
    parser.add_argument('mountpoint', help='Mount point directory')

    parser.add_argument('-o', '--options', default='', help='Mount options')
    parser.add_argument('-n', action='store_true', help='Do not write to /etc/mtab (ignored)')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose mode')
    parser.add_argument('-s', action='store_true', help='Tolerate sloppy mount options (ignored)')
    parser.add_argument('-t', '--type', help='Filesystem type (ignored)')

    args = parser.parse_args()

    return args


def parse_shadowfs_options(options_str):
    """
    Parse mount options and separate shadowfs-specific from FUSE options.

    Returns:
        (shadowfs_opts, fuse_opts): Tuple of shadowfs options dict and FUSE options list
    """
    shadowfs_opts = {}
    fuse_opts = []

    if not options_str:
        return shadowfs_opts, fuse_opts

    for opt in options_str.split(','):
        opt = opt.strip()
        if not opt:
            continue

        if '=' in opt:
            key, value = opt.split('=', 1)
            key = key.strip()
            value = value.strip()

            # ShadowFS-specific options
            if key == 'config':
                shadowfs_opts['config'] = value
            elif key in ['debug', 'foreground', 'log_file']:
                shadowfs_opts[key] = value
            else:
                # FUSE option with value
                fuse_opts.append(opt)
        else:
            # Boolean options
            if opt in ['debug', 'foreground']:
                # ShadowFS-specific boolean flags
                shadowfs_opts[opt] = True
            else:
                # FUSE boolean option
                fuse_opts.append(opt)

    return shadowfs_opts, fuse_opts


def build_shadowfs_command(source, mountpoint, shadowfs_opts, fuse_opts, verbose=False):
    """Build the shadowfs CLI command."""
    # Find shadowfs executable
    shadowfs_bin = None

    # Check standard locations
    for path in ['/usr/local/bin/shadowfs', '/usr/bin/shadowfs', '/usr/local/bin/python', '/usr/bin/python3']:
        if os.path.exists(path) and 'python' not in path:
            shadowfs_bin = path
            break

    if not shadowfs_bin:
        # Try to find in PATH
        try:
            result = subprocess.run(['which', 'shadowfs'], capture_output=True, text=True, check=True)
            shadowfs_bin = result.stdout.strip()
        except subprocess.CalledProcessError:
            # Development mode: try python -m shadowfs.cli
            try:
                result = subprocess.run(['which', 'python3'], capture_output=True, text=True, check=True)
                python_bin = result.stdout.strip()
                # Check if shadowfs module is available
                test_result = subprocess.run(
                    [python_bin, '-c', 'import shadowfs.cli'],
                    capture_output=True
                )
                if test_result.returncode == 0:
                    # Use python -m shadowfs.cli
                    shadowfs_bin = python_bin
                    if verbose:
                        print("Using development mode: python -m shadowfs.cli", file=sys.stderr)
                else:
                    print("Error: shadowfs command not found", file=sys.stderr)
                    print("Please install shadowfs package", file=sys.stderr)
                    sys.exit(1)
            except subprocess.CalledProcessError:
                print("Error: shadowfs command not found", file=sys.stderr)
                print("Please install shadowfs package", file=sys.stderr)
                sys.exit(1)

    # Build command
    # Check if we're using python (development mode)
    if 'python' in os.path.basename(shadowfs_bin):
        cmd = [shadowfs_bin, '-m', 'shadowfs.cli', source, mountpoint]
    else:
        cmd = [shadowfs_bin, source, mountpoint]

    # Add config if specified
    if 'config' in shadowfs_opts:
        cmd.extend(['-c', shadowfs_opts['config']])

    # Build -o options string from FUSE options
    if fuse_opts:
        cmd.extend(['-o', ','.join(fuse_opts)])

    # Add foreground if specified (for debugging)
    # Note: Normal mounts should NOT use foreground
    if shadowfs_opts.get('foreground'):
        cmd.append('-f')

    # Add debug if specified
    if shadowfs_opts.get('debug'):
        cmd.extend(['-o', 'debug']) if '-o' in cmd else cmd.extend(['-o', 'debug'])

    if verbose:
        print(f"Executing: {' '.join(cmd)}", file=sys.stderr)

    return cmd


def main():
    """Main entry point for mount helper."""
    try:
        args = parse_mount_args()

        # Validate paths
        source_path = Path(args.source)
        if not source_path.exists():
            print(f"Error: Source directory does not exist: {args.source}", file=sys.stderr)
            sys.exit(1)

        if not source_path.is_dir():
            print(f"Error: Source is not a directory: {args.source}", file=sys.stderr)
            sys.exit(1)

        mountpoint_path = Path(args.mountpoint)
        if not mountpoint_path.exists():
            print(f"Error: Mount point does not exist: {args.mountpoint}", file=sys.stderr)
            sys.exit(1)

        if not mountpoint_path.is_dir():
            print(f"Error: Mount point is not a directory: {args.mountpoint}", file=sys.stderr)
            sys.exit(1)

        # Parse options
        shadowfs_opts, fuse_opts = parse_shadowfs_options(args.options)

        # Build and execute shadowfs command
        cmd = build_shadowfs_command(
            args.source,
            args.mountpoint,
            shadowfs_opts,
            fuse_opts,
            args.verbose
        )

        # Execute shadowfs
        # For normal mounts, shadowfs will daemonize itself
        result = subprocess.run(cmd)
        sys.exit(result.returncode)

    except KeyboardInterrupt:
        print("\nInterrupted by user", file=sys.stderr)
        sys.exit(130)
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
